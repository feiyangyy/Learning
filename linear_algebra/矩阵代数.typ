#import "@preview/cetz:0.2.2"
#set text(
  font: "New Computer Modern",
  size: 6pt
)
#set page(
  paper: "a5",
  margin: (x: 1.8cm, y: 1.5cm),
)
#set par(
  justify: true,
  leading: 0.52em,
)

#set heading(numbering: "1.",)
= 映射
映射在测度、微积分、代数以及概率论中都有所体现，矩阵与向量相乘，可以看做对向量中的一种映射变换。新版的教材中删去了这个部分（反而显得矩阵代数这部分有点生硬）
#let bs = $bold(S)$
#let bss = $bold(S^')$
#let x = $x$
#let y = $y$; #let f = $f$
== 映射
如果有一个映射法则$f$, 对于每一个$x in #bs$，都能在#bss 找到唯一一个对应的元素$y in #bss$。此时我们把#y 叫做 #x 在映射法则#f 下的象，记作$f(x)$, #x 被称作 #y 的原象。我们映射法则f记作:

$f: #bs -> #bss \
x |-> y
$

集合#bs 叫做 #f 的#highlight()[定义域], #bss 叫做#f 的 #highlight()[陪域]。要注意#f 的取值的集合是陪域的一个子集

== 映射的象集
对于法则$ f: #bs -> #bss \ x |-> y$ ， 所有的$x in #bs$ 对应的 $f(x)$的映射的结果的集合，叫做#f 的象集，简称象， 记作 $Im f := {f(x) | x in #bs} := f(#bs)$,显然$f(#bs) in #bss$

== 满射
如果$f(#bs) = #bss$，则称$f: #bs -> #bss$ 是一个满射。$f(#bs) = #bss$ 的充要条件是#bss 中的任意元素都能在#bs 中找到一个原象（注意，不一定是唯一一个）

== 单射
如果对于任意 $a ,b in #bs, a != b <=> f(a) != f(b)$, 则称#f 是一个单射。
单射的充要条件是，对于$a,b in #bs, f(a), f(b) in #bss, 若 f(a) = f(b) -> a = b$
可以用一次线性函数记忆单射，用二次函数记忆非单射
== 双射
如果映射#f 既是满射也是单射，则$forall y in #bss$ 都能在#bs 找到#highlight()[唯一一个]原象。此时称#f 是双射， 或者说一一对应
用一次函数记忆双射，用二次函数记忆非双射

双射和单射的主要区别是，$Im f in #bss and Im f != #bss$， 双射的话，就是单射#f 满足$Im f = #bss$

== 原象集
设$f:#bs -> #bss$,  则对应于$b in #bss$, 所有在#bs 中的元素集合$a in W$， 能使得$f(a) = b$。 我们把$W$ 称作$b$ 的原象集，记作$f^(-1)(b) := {x |x in #bs,  f(x) = b}$，显然，如果$b in #bss \\ Im f -> f^(-1)(b) = emptyset$. 如果$b in Im f$, 则$f^(-1)(b)$ 成为 b 的纤维

== 相等映射
#let mf=$f$; #let mg=$g$
如果映射#mf 和 #mg 有相同的#highlight()[定义域 陪域]，并且$forall x in #bs, f(x) = g(x)$， 则称#mf 和 #mg 相等

== 恒等映射
如果映射$f: S -> S, f(x) = x$， 即将#bs 中的元素映射为自己，则称这个映射为恒等映射，或者单位映射, 记$1_s$（#highlight()[这等价于后文中的单位矩阵])

可以用$y = f(x)$ 或者单位矩阵 记忆恒等映射，注意恒等映射的定义域是#bs, 象集也是#bs, 他是一个双射

如果一个$f: #bs -> #bs$， 我们通常把#f 称作一个变换， 如果一个$f:#bs -> K$ （K是数域)，则我们把#f 叫做#highlight()[函数]



== 复合映射
#let bsss = $bold(S^(''))$
#let g =$g$
对于映射$g: #bs -> #bss, f:#bss -> #bsss$，我们把两者的复合定义为两者的乘积:$(f g)(a) := f(g(a))$， 我们用语言来描述这件事，#f #g 定义为 用#f 将#g 在#bss 下的象集映射到#bsss 中。 由此可见，映射的乘积#highlight()[不一定能交换]， 且其乘积不一定有定义(需要满足映射的定义域的条件, 即#g 的象集要是#f 的定义域的子集)

在数学分析中，$u = g(x), f(g(u))$ 称为复合函数

由此直接体现了矩阵乘法的含义：#highlight()[映射的复合]

容易验证:$f 1_s = f$, $1_s f = f$. 让我们简单的证明这个东西，$forall x in #bs, 1_s(x) = x, ->f(1_s(x)) = f(x) = f, x in #bs$, $forall x in #bs, 1_s(f(x)) = f(x) = f$, 从而恒等映射与任意映射#f 的乘积都等于映射自身，并且满足#highlight()[交换律]


=== 定理 在有定义的情况下，映射的乘积满足结合律 
#let bssss = $bold(S^(''''))$
即$h: #bs -> #bss, g:#bss -> #bsss, f:#bsss -> #bssss, (f g h) = (f g) h = f (g h)$. 
证明:
$
 forall x in #bs,  (f g h) x = f(g(h(x))), (f(g h))x = f((g h) x) = f(g(h(x))), ((f g) h)x = ((f g)(h(x))) = f(g(h(x))) = (f g h) x
$
因此三者相等（威力强大啊，矩阵乘法的结合律直接就被清楚诠释了）

== 逆映射
对于映射$f: #bs -> #bss, g:#bss -> #bs$,如果满足:$f g = 1_(#bss), g f = 1_(#bs)$ 那么称#f 是可逆的， #g 是 #f 的唯一一个逆映射。
下面证明唯一性：假设#g 和#h 都是#f 的逆映射，则 $h f g = (h f) g = 1_(#bs)g = g = h f g = h (f g) = h 1_(#bss) = h $，因此映射唯一


#let inf=$f^(-1)$
如果#f 是可逆的，我们用$f^(-1)$ 表示$f$的逆，那么$f#inf = 1_(#bss), #inf f = 1_(#bs)$，因此#inf 也是可逆的，他的逆就是#f， 从而$(#inf)^(-1) = f$

=== 定理（映射的可逆定理） 映射$f:#bs -> #bss$ 可逆的充要条件是#f 是双射
==== 引理 如果映射$f:#bs ->#bss, g:#bss -> #bs$ 满足$g f= 1_#bs$,则f是一个单射，g是一个满射
证明#f 是单射：令$a_1, a_2 in #bs, 且 f(a_1) = f(a_2) => a_1 = (g f)a_1 = g(f(a_1)) = g(f(a_2))= (g f)a_2 = 1_#bs a_2 = a_2;$ 从而#f 是单射 

证明#g 是满射， 这里要注意#f 的定义域是#bs, #f 的象集$in #bss$,  #g 的定义域是#bss, $forall a in #bs, g(f(a)) = (g f) a = a$,按照满射的定义，$forall a in #bs, f(a)$是a 在映射#g 的一个原象。这里要注意,此处还没有要求$f(a)$的象集就是#bss


==== 定理证明:
必要性: 设#f 可逆，有引理可以知道$cases(#f #inf = 1_#bs -> f 单 射, #inf #f = 1_#bss -> f 满 射)$ 从而#f 是双射

充分性: 设#f 双射，对于$forall a^' in #bss$,  由#f 的满射性质可知，$exists a in #bs s.t. f(a) = a^'$. 又因为#f 为单射，从而这个$a$唯一。 设$g: #bss -> #bs, g(a^') = a$,那么$(f g)a^' = f(g(a^')) = f(a) = a^' => (f g) = 1_#bss$, $(g f)a = g(f(a)) = g(a^') = a => (g f) = 1_#bs $. 结合两者，#f 可逆 定理得证。

这里比较坑的是被定义域困住了，一直在想定义域的事情

=== 习题
习题6. 对于#bs 和 #bss, 如果存在一个双射 $f:#bs -> #bss$， 则称#bs 和 #bss 有相同的基数，证明整数集$Z$ 和偶数集$O$ 有相同基数。

证：
$forall x in Z, f := 2x -> f(x) in O$ ，并且，$forall a, b in Z, a != b, f(a) = 2a != 2b = f(b) ->$ f 是一个单射
$forall y in O => y/2 in Z => f(y/2) = y$ 即，$y/2 in Z$ 是 $y in O$ 在映射#f 下的原象，从而#f 是双射。 两者同基

这是一个很奇妙的性质，一个东西的子集和他同基（等势）

#highlight()[所有和$Z$同基数的都是可数集合]

有理数集也是可数集，找个时间证一下。

= 矩阵的基本运算
前面章节中，矩阵是通过线性方程组求解，我们研究其系数矩阵而直接引入的，除了线性方程组外，矩阵还可以表示具有关系型的表格、空间或平面中的变换等。本文主要就是介绍矩阵本身支持的运算及其性质。

== 矩阵的加法、数量乘法
=== 定义1. 矩阵相等
#let A=$A$ ; #let B=$B$; #let K=$K$ ; #let C=$C$; #let sn=$s times n$
如果#A 与 #B 都是数域 #K 上的$s times n$ 的矩阵， 并且$a_(i,j) = b(i,j)$ 则称#A #B 相等，记作#A = #B

=== 加法定义
在数域#K 上，令$C_(s times n) = (c_(i, j))_(s times n) = (a_(i,j) + b_(i, j))_(s times n)$， 称#C  是 #A #B 的和，记作$C = A + B$。从定义可以看出，两个矩阵只有形状相同才能相加（即两者要在同一空间）

=== 数量乘法定义
设有矩阵$A_(#sn) = (a_(i , j))_(#sn), k in K$, 令$M = (k a_(i,j))_(#sn)$，称M为矩阵A和k的数量积，记为$M=k A$

在前面的向量空间中，我们除了要定义运算外，还要定义 0 元、 负元（回忆向量空间中，0元是所有分量为0的向量，$bold(a)$的负元是$-bold(a)$ ），类似的，我们定义$bold(0)_(s times n)$ (教材上没有个定义，我们暂且叫做0矩阵); 以及定义$-(a_(i,j))_(#sn) = -A$，把他叫做A的负矩阵。我们设有$C_(#sn)$，则可以验证 #A  #B  #C 满足以下8条规则:
1. 加法交换律 #A + #B  = #B  + #A 
2. 加法结合律 #A + #B + #C  = (#A + #B) + #C
3. #A 加上 0 矩阵等于 #A  $A + bold(0) = A$
4. #A 加上它的负矩阵(负元) 等于 0 矩阵 $A + (-A) = bold(0)$
  - 0 元也称为 加法的单位元
5. 1#A = #A
6. 数量乘法结合律 $k l#A = k(l#A)$
7. 数量乘法分配律 $(k+l)#A = k#A  + l #A$
8. $k (A + B)= k A + k B$

可见，如果我们把所有$#sn$ 这样的矩阵看做一个集合，这个集合也满足我们在向量空间中定义（对于加法和数量乘法封闭），但唯一不同的是，这些元素都是矩阵而不是向量

== 矩阵乘法定义

// #set page(width: auto, height: auto, margin: .5cm)
// 所有数学部分，填充色
// #show math.equation: block.with(fill: red, inset: 1pt)
#grid(
  columns: (1fr, 0.5fr),
  align(left)[
    #let t= $theta$
    #let p=$phi$

    如右图所示，在平面坐标系上有个两个单位向量$bold(a) = (x,y)^T$ 以及$bold(b) = (x^',y^')^T$, 它们与$x$ 轴夹角分别时#sym.alpha, #sym.beta+#sym.alpha. 那么易知$cases(x=cos(alpha), y=sin(beta)), cases(x^' = cos(alpha + beta), y^' = sin(alpha + beta))$;$bold(b)$ 可以看做$bold(a)$ 逆时针旋转$beta$ 角度得来。我们考虑两者的坐标关系:

    $cases(x^' = cos(alpha)cos(beta) + sin(alpha)sin(beta), y^' = sin(alpha)cos(beta) - cos(alpha)sin(beta)) => cases(
      x^' = cos(beta)x - sin(beta)y, y^' = sin(beta)x + cos(beta)y 
    ) => A=mat(cos(beta), -sin(beta);sin(beta), cos(beta))$ $A$为系数矩阵。即我们可以用$A$ 这样的矩阵（方程组）表达旋转，它将一个向量，变为另外一个向量并且它只和旋转度数$beta$有关（这个和前面方程组求解不同）由此对于平面空间中，任意旋转度数$phi$的旋转矩阵就定义为:$A = mat(cos(phi), -sin(phi); sin(phi), cos(phi))$.那么对于旋转$phi$ 再旋转$theta$度数而言，其旋转矩阵就表达为:$C = mat(cos(phi + theta), -sin(phi + theta); sin(phi + theta), cos(phi + theta)) = mat(cos(#p)cos(#t) - sin(phi)sin(theta), -(sin(#p)cos(#t)+ cos(#p)sin(#t));sin(#p)cos(#t)+ cos(#p)sin(#t), cos(#p)cos(#t) - sin(phi)sin(theta))$, 其中 #t 的旋转矩阵是$T= mat(cos(#t), -sin(#t); sin(#t), cos(#t))$  观察可得:$cases(c_11= a_11 t_11  + a_12  t_21 , c_12= a_211 t_12  + a_12  t_22, c_21= a_21 t_11  + a_22  t_21, c_22= a_21 t_12  + a_22  t_22)$
  ],
  align(right)[
  #cetz.canvas({
      import cetz.draw: *
      let vmin = -1.5; let vmax = 1.5
      let a_x = calc.cos(30deg)
      let a_y = calc.sin(30deg)

      let b_x = calc.cos(60deg)
      let b_y = calc.sin(60deg)
      grid((vmin, vmin), (1.5, 1.5), step: 0.5, stroke: gray + 0.2pt)
      circle((0,0), radius: 1)
      line((vmin, 0), (vmax, 0), mark: (end: "stealth"))
      content((), $x$, anchor: "west")
      line((0, vmin), (0, vmax), mark: (end: "stealth"))
      content((), $ y $, anchor: "south")
      // 原点， 原点-> 起始边， 原点到终边
      // 角度本身不画边
      // 只不过它通过边来画角度，即使终点定义错了，影响貌似也不大
      cetz.angle.angle((0,0), (1,0), (calc.cos(30deg), calc.sin(30deg)),
        label: text(black, [$alpha$]), inner:true)
      
      cetz.angle.angle((0,0), (calc.cos(30deg), calc.sin(30deg)), (calc.cos(60deg), calc.sin(60deg)),
        label: text(black, [$beta$]), mark: (end: "stealth"), radius: 0.8)

      // 第一个应该是原点，第二个是终点
      line((0,0), (calc.cos(30deg), calc.sin(30deg)))
      content((a_x+0.3, a_y), $(x,y)$, anchor: "south")
      line((0,0), (calc.cos(60deg), calc.sin(60deg)))
      content((b_x+0.3, b_y+0.1), $(x^',y^')$, anchor: "south")
    }) 
  ]
)

由此$C$ 可以由$A T$的某种运算关系表示，这种运算我们定义为矩阵的乘法（个人认为这个例子不是太好，作为引出矩阵乘法定义有点生硬，这里主要是为了练习排版和作图，才把这段记下来）
== 矩阵乘法
设$A=(a_(i j))_(#sn), B = (b_(i j))_(n times m), C = (c_(i j))_(s times m)$  并且有$c_(i j) = sum_k a_(i, k) b_(k, j)$ 用文字表达即，$c_(i j)$ 通过选定A 矩阵的第$i$ 行， 选定B矩阵的第$j$列，然后，从$k = 1->n$, 依次取A的第$i$行的第k个(列)元素 与 B矩阵第$j$列的第k个(行)元素相乘，然后求和

由矩阵乘法可见，能使得$a(i, k), b(k, j)$ 均有意义的条件是A矩阵的列数与B矩阵的行数相等，A矩阵也叫做#highlight()[左矩阵]， B矩阵也叫#highlight()[右矩阵]。 矩阵的乘法运算中涉及到 乘法和加法，有时候这个运算会被定义到计算机的DSP指令集中，叫做乘加运算(muladd)

== 矩阵乘法性质
以下均假设所引用的矩阵可以相乘
=== 结合律 $A B C = (A B)C = A(B C)$
#let nm = $n times m$
#let mr = $m times r$
#let sr = $s times r$
#let ma= $A_(#sn)$;#let mb =$B_(#nm)$ 
#let b0 =$bold(0)$
设$A=(a_(i j))_(#sn), B = (b_(i j))_(#nm) C= (c_(i j))_(m times r)$
在矩阵的形状上， 等式两边都是#sr 矩阵。 下面证明其每个元素相等

$((A B)C)_(i j) = sum_k [(A B)_(i k) c_(k j)] = sum_k {[sum_l a_(i l) b_(l k)] c_(k j)}  = sum_k sum_l [a_(i l) b_(l k) c_(k j)] -> c_(k j) 乘 法 分 配 到 左 侧\
(A(B C))_(i j) = sum_k [a_(i k) (B C)_(k j)] = sum_k {a_(i k) [sum_l b_(k l) c_(l j)]} = sum_k sum_l [a_(i l) b_(l k) c_(k j)]
 -> a_(i l) 乘 法 分 配 到 右 侧$
 可见两者相等

 与实数域里面的乘法的交换律不同，矩阵乘法一般不满足交换律，首先$A B$ 交换的$B A$ 就不一定能相乘。当$s != m$ 时，$#mb #ma$ 就没有定义。其次即便是$B A$ 能够相乘，其结果也可能和$A B$ 不同。比如 $s = m != n$时，$#ma #mb = C_(s times s), #mb #ma= D_(n times n)$. $C$ $D$形状不同

 === 零因子
 设$A = mat(0, 1; 0, 0) , B = mat(0, 0; 0, 1;)，则 A B = mat(0, 1; 0, 0); B A = mat(0, 0;0, 0)$ 可见 $A != 0 且 B != 0 <==>^(不 能 得 出) A B != 或 B A = 0$

对于#A，如果存在一个矩阵$#B != 0$能够使得 #A #B = #b0, 则把#A 称作一个左零因子，如果存在一个$#C  != #b0$，并且#C #A = #b0 则把A叫做一个右零因子。左右零因子统称为零因子

=== 左分配律
$A(B+C) = A B + A C$
=== 右分配律
$(B + C) A = B A + C A$
#let bdef = $(b_(i j))_(#sn)$; #let cdef = $(c_(i j))_(#sn)$; #let aef = $(a_(i j))_(#nm)$

下面对右分配律证明，设$B=#bdef,C = #cdef, A = #aef$，那么$[(B + C) A]_(i j) = sum_k (A+B)_(i k) c_(k j) = sum_k [(a_(i k) + b_(i k))]c_(k j) = sum_k a_(i k) c_(k j) + sum_k b(i k) c(k j) = B A + C A$ 得证

左分配律证明方法类似

可见矩阵乘法相比较数域中的乘法性质较差一些，矩阵间的乘法不一定存在，且，矩阵的乘法定律也比较受限

=== 数量乘法规律
$k(A B) = (k A)B = A (k B)$ 这是因为数量乘法可以提到求和符号外边，从而自然得证

=== 单位矩阵
#let idef =$bold(I)$
对于n阶#highlight()[方阵]，只有对角线上的元素为1，其他全为0的矩阵，称为单位矩阵，记作$#idef _n$ 或者#idef, 容易验证:
$#idef _s A_(#sn) = A_(#sn); A_(#sn) #idef _n = A_(#sn)$ ，我们证一下第一个$(#idef _s A_(#sn))_(i j) = sum_k #idef _(i k) a_(k j) = a_(i j) <== because cases(#idef _(i k) = 0 当 (k != i), #idef _(i k) = 1 当 (k = i))$ 

如果 #A 是n阶方阵，那么$#idef A = A #idef = A$

=== 数量矩阵
对角线元素全为$k$，其余元素全为0的方阵称为数量矩阵，那么显而易见其可以表示为$k #idef in W$, 那么很自然有
$
k#idef + l#idef = (k + l)#idef in W \
k(l #idef) = (k l)#idef in W \
(k#idef)(l#idef) = (k l)#idef in W
$
因此可见$W$ 是一个封闭的空间（特别是第三个公式），注意其中第三个公式需要展开得出=== 可交换矩阵

如果#A#B =#B#A 则称$A B$ 时刻可交换的，可交换蕴含两个强限制条件1. #A#B #B#A 有定义且两者的结果相等 。我们容易验证$k #idef A = A (k #idef)$. 并且当这个等式成立时，A一定是和$#idef$ 同阶的#highlight()[方阵]

对于n阶矩阵$A_n$，我们可以定义他的n次幂$A^m = A dot A dot A ..., m>=0, m in Z$, 同时我们定义$A^0 =^(d e f) bold(I)$, 那么，就有$A^k A^l = A^(k + l) => 形 式 定 义$， $(A^k)^l = A^(k l) => 形 式 定 义$

即便$(A B)$ 是一个n阶方阵， $(A B)^k$ 有定义，由于 A B 一般不可交换，从而一般$(A B)^k != A^k B^k$.

#highlight(fill: red)[如果#A #B 可以交换]，则$(A B)^k = product_(i = 1)^k (A B)$，因为 #A #B 可以交换，则根据乘法的结合律，$(A B)_i (A B)_(i+1) = (A A)_i (B B)_(i+1) <- 交 换 中 间 的 A B$,这样，我们可以依次把所有的#A 逐个交换到乘积的前面，剩下的就是#B 的乘积，从而$product_i (A B)_i = product_i A_i product _i B_i = A^k B^k$

矩阵的二项式定理（主要复习二项式定理）
对于实数域的二项式定理:
$(a+b)^n = sum_k C_n^k a^k b^(n-k)$， 推理如下：

考虑乘法的分配律$(a+b)c = a c + b c$, 那么$(a+b)^2 = (a+b)(a+b) = a(a+b) + b(a+b) = a a + a b + b a + b b = a^2 + b^2 +2a b$ 这么展开来看：
1. 对于第1个乘法单元以分配律展开，a(a+b)，#highlight()[相当于选择第一个乘法单元中的a 和后者相乘],b(a+b) 类似的是选择...中的b与后者相乘
2. 对第二个乘法单元展开，a a 相当于第2个乘法单元也选择a ， 则产生$a^2$,  $a b$ 是第二个乘法单元选择b产生的结果。 同理 $b a$是1.选择b展开时，加上本单元选择a 展开产生， $b^2$结论类似

由此，我们可以推论$(a+b)^n$ 中，$a^k b^(n-k)$, 其系数的产生由$n$个乘积累单元中选择$k$个a，再从剩余的乘积单元中选择$k$个b产生，则其系数就是$C_n^k C_(n-k)^(n-k)=C_n^k$ 这个只能便于理解和记忆，下面让我们来正式的证明他：

step 0. 先证明帕斯卡法则 $C_(n-1)^k + C_(n-1)^(k-1) = C_n^k $

左边:

$C_(n-1)^k + C_(n-1)^(k-1) = frac((n-1)!, k! (n-1-k)!) + frac((n-1)!, (k-1)!(n-k)!) = (n-1)![frac(1, k!(n-k-1)!) + frac(1, (k-1)!(n-k)!)] = (n-1)!(frac((k-1)!(n-k)! + k!(n-1-k)!, k!(n-k-1)!(k-1)!(n-k)!)) = \
(n-1)!(k-1)![frac((n-k)! + k(n-k-1)!, k!(n-k-1)!(k-1)!(n-k)!)] = (n-1)!(n-k-1)![frac((n-k) + k, k!(n-k-1)!(n-k)!)] = (n-1)![frac((n-k) + k, k!(n-k)!)] = frac(n (n-1)!, k! (n-k)!) = n!/(k!(n-k)!) = C_n^k$ 


step 1. 假设$(a+b)^n = sum_(k=0)^n C_n^k a^k b^(n-k)$成立，易验证n = 1时, 等式成立，现在假设其在n=N 时成立

step 2. 我们证明(n= N+1)时也成立，证明如下:

$(a+b)^(N+1) = (a+b)[sum_k C_N^k a^k b^(N-k)] = a sum_k C_N^k a^k b^(N-k) + b sum_k C_N^k a^k b^(N-k) = sum_k C_N^k a^(k+1) b^(N-k) + sum_k C_N^k a^k b^(N-k +1) = sum_k A_k + sum_k B_k
$ 
对于$A_k, B_k$ ，令$k=t, 0<=t<=N-1）$, 对于$B_k$，令$k=t+1$，那么可以发现 $A_t + B_(t+1) = C_N^t a^(t+1)b^(N-t) + C_N^(t+1) a^(t+1)b^(N-t) = [a^(t+1)b^(N-t)][C_N^t +  C_N^(t+1)] = C_(N+1)^(t+1)(a^(t+1)b^(N+1-(t+1))) -> C_(N+1)^(tau)(a^(tau)b^(N+1-(tau))), 1 <= tau=t+1 <= N$， 这里$t $不能取N的原因是， 对于$B_k, 0 <= k <= N$

再证明，$tau=N+1$ 时也成立:
当要取$b^0$项时，可知$B_k$任意项不能产生$b^0$, $A_k$ 能取$b^0$时 只有$A_k_(k=N) = C_N^N a^(N+1)b^0 = C_(N+1)^(N+1) a^(N+1) b^(N+1-(N+1)) = C_(N+1)^(tau)(a^(tau)b^(N+1-(tau))) _(tau=N+1)$

再证明，$tau=0$ 时也成立：当要取$a^0$时，可知$A_k$ 不能产生$a^0$, 而$B_k$ 能取得$a^0$时 只有$B_k_(k=0) = C_(N)^N a^0 b^(N+1) =  C_(N+1)^(tau)(a^(tau)b^(N+1-(tau))) _(tau=0)$

从而，$forall 0<=k<=N+1, (a+b)^(N+1) = C_(N+1)^(k) a^(k) b^(n-k)$. 二项式定理得证

回到矩阵：

这里说明，当#A #B 不能交换时，二项式展开产生的#B #A 不一定有定义，即便有 他和#A#B 也不相等,即形如#B#A#A#B 这样的项不能合并，从而不适用二项式定理。对于可以交换的矩阵，不存在上述限制，则可以适用于二项式定理

=== 矩阵运算的结果的转置
转置真的是最讨人厌的东西之一, 形状变了，又要用符号表示和原矩阵的关系

容易证明:
1. $(#A + #B)^T = #A^T + #B^T$
2. $(k A)^T = k(A)^T$
3. $(A B)^T = B^T A^T$ #highlight()[这个需要特别留意]

这里先证明一下1. 设$A_(#sn), B_(#sn), C = (A + B)_(#sn), D_(n times s) = C^T$

$D_(n times s)_(j i) = c_(i,j)= a_(i, j) + b_(i.j);\
(A^T + B^T)_(j, i) = (A^T_(j,i) + B^T_(j, i)) = a_(i,j) + b_(i,j)
$

可见两者相等

在证明一下3.

设$A_(#sn), B_(#nm), C_(s times m) = A B $, 所以

$c_(i ,j) = sum_k a_(i, k) b_(k, j) = C^T_(j, i) \
(B^T A^T) (j, i) = sum_k B^T_(j, k) A^T_(k, i) = sum_k b_(k, j) a_(i, k) = sum_k a_(i, k)b_(k, j) => \
(A B)^T_(j, i) = C^T(j, i) = (B^T A^T)(j,i)   =>  (A B)^T = B^T A^T
$

=== 用矩阵表示线性方程组
#let bx=$bold(x)$
#let ba=$bold(a)$; #let bb=$bold(b)$
严格来说，原书到目前为止并没有给出矩阵和向量的相乘定义，这里直接把列向量当做一个n行1列的矩阵来看其实缺少说明，因为毕竟不是同一个东西.同时也不能体现和前文中引入矩阵乘法时矩阵的"映射"作用
这里给一个来自#link("https://mbernste.github.io/posts/matrix_vector_mult/#:~:text=As%20a%20%E2%80%9Crow%2Dwise%E2%80%9D,of%20a%20vector%20as%20coefficients")[github]的参考定义:

假设#A  的列数和列向量#bx 的元素数目相等，则定义矩阵和向量的乘法
$#A #bx :=  sum_i x_i #ba _i = #bb,
$ 其中$#ba _i$ 是矩阵的列向量,$x_i$ 是#bx 的各分量，#bb 是和#bx 同属于$K^n$空间，从而#A 是一个#highlight()[变换]

如果我们把线性方程组的未知量写成列向量$#bx = (x_1, x_2, ..., x_n)^'$，常数项写作$#bb = (b_1, b_2, ..., b_n)^'$, 那么线性方程组就可以写作:$A #bx = #bb$, A是方程组的系数矩阵，同理，齐次线性方程组就可写作$#A #bx = bold(0)$

=== 从其他角度看矩阵乘法
#let avecs = $(#ba _1, #ba _2 , ..., #ba _n)$
设$A_(#sn), B_(#nm)$, 如果把#A 以列向量形式表示，则$A = #avecs, #ba _i in K^s$,那么

$A B = #avecs mat(b_11, b_12, ..., b_(1 m);...; b_(n 1), b_(n 2), ..., b_(n m)) = (b_11#ba _1 + b_21 #ba _2 + ...+ b_(n 1)#ba _n,...,b_(1 m)#ba _1 + b_(2 m) #ba _2 + ...+ b_(n m)#ba _n)$， 即结果矩阵$C_(s times m)$ 列向量，#highlight()[是以矩阵B的各列的线性组合而生成]，C矩阵的列向量个数等于B矩阵的列，C矩阵的#highlight(fill:red)[列]向量$bold(c)_i in <#ba _1, #ba _2, ..., #ba _n>$

把#B 按照行向量形式表示，则$bold(B) = (#bb _1, #bb _2, ..., #bb _n)^', #bb _i in K^m$，那么矩阵乘法就可以写作$A bold(B) =
mat(a_11, a_12, ..., a_(1 n); ...; a_(s 1), a_(s 2), ...,a_(s n))vec(#bb _1, ..., #bb _n) = vec(a_11 #bb _1 + a_12 #bb _2 + ... + a_(1 n)#bb _n, ..., a_(s 1) #bb _1 + a_(s 2) #bb _2 + ... + a_(s n)#bb _n)$, #C 的各行向量是#B 矩阵的各行向量通过以#A 的各行为系数线性组合而成，从而#C 的#highlight(fill:red)[行]向量一定在$<#bb _1, #bb _2, ..., #bb _n>$ 中

列列组合，行行组合

= 特殊矩阵
== 基本矩阵
在$M_(#sn)$ 中，除了0矩阵外， 我们定义只有一个元素为1，其他元素为0的矩阵为基本矩阵。我们把$(i, j)$ 元为1，其余元素为0的矩阵记作$E_(i,j)$. 因此在$M_(#sn)$ 中一共有$s times n$ 个基本矩阵。 $M_(#sn)$中的任意矩阵可以表示为$sum_i sum_j a_(i j)E_(i j)$

=== 基本矩阵乘法(IMPORTANT)
前面说过，矩阵乘法，乘积的行向量是右矩阵的行向量的线性组合，组合系数是左矩阵的各行，让$E_(i j)A$,则相当于，结果矩阵只有第$i$行不为0，并且其取得是#A 的第$j$行. 从而，其相当于将$#ba _j$ 搬到了第$i$行。注意$A$的行数和乘积矩阵的行数不相等($r_j -> r_i$)

如果有$B E_(i j)$，按照矩阵乘法的第二种定义, 则代表乘积矩阵的各列是B的矩阵的各列的线性组合，从而，乘积矩阵的第$j$列有值，其取得是B的第$i$列。从而他的作用是将B矩阵的第$i$列变换到第$j$列 $(c_i -> c_j)$

=== 定理， 和任意n级方阵可交换的矩阵，一定是数量矩阵
1. 设#B 为矩阵，且可以和 n级方阵#A 交换， 即 #A#B =#B#A $=>$ #B 也是n级方阵
2. 设#B 可以和任意n级方阵交换，那么$E_(1,j)A=A E_(1,j)$， 左侧: 选择A的第$j$行到1行；右侧，选择A的第1列到第$j$ 列，即如下的两个矩阵相等:
$
mat(a_(j,1), a_(j,2), ..., a_(j,n);
0, 0,...,0;
...;
0, 0,...,0;) = 
mat(0, 0, ..., a_(1,1), 0, ..., 0;
0, 0, ..., a_(2,1), 0, ..., 0;
...;
0, 0, ..., a_(n,1), 0, ..., 0;) => a_(j,k) = 0, k != j; a_(j,j) = a_(1,1), j in [1, n];
$
根据$a_(j,j) = a_(1,1), j in [1, n]; => A = a_(1,1) I$, 从而A是数量矩阵 . Q.E.D
== 对角矩阵
#let diag=$d i a g$
除了主对角线之外的元素全为0的方阵称为对角矩阵，形如$mat(a_1,0,...,0;
0,a_2, ..., 0;
...,...,...,...;
0,0,..., a_n)$ 记为$#diag{a_1, a_2, ..., a_n}$

=== 对角矩阵和普通矩阵相乘
==== 1. 左乘 对角矩阵：

设$D=diag{d_1, d_2, ..., d_n}$, 则$D A = mat(d_1, 0, ..., 0;0, d_2, ...,0; ...; 0, 0, ..., d_n)vec(#ba _1, #ba _2, ..., #ba _n) = vec(d_1 #ba _1, d_2 #ba _2 , ..., d_n #ba _n)$，(记住#highlight()[结果矩阵的各行是右矩阵的各行以左矩阵的各行线性组合而成] 总是记错，下意识觉得行列对称)。 这个式子表明，A 左乘以D，就是分别把A的各行乘以D对应的各行非0元

==== 2. 右乘 对角矩阵
$A D= mat(#ba _1, #ba _2, #ba _3, ..., #ba _n) mat(d_1, 0, ..., 0;0, d_2, ...,0; ...; 0, 0, ..., d_n) = mat(d_1 #ba _1, d_2 #ba _2, ..., d_n #ba _n)$ (记住#highlight()[结果矩阵的各列是左矩阵的各列以右矩阵的各列线性组合而成])。 该式表明，A右乘以D，就是把A的各列乘以D的各列非0元

3. 对角矩阵之间的运算
#let da = $diag{a_1, a_2, ..., a_n}$
#let db = $ diag {b_1, ..., b_n} $
根据 1. 2.， 
$#da dot #db = diag{a_1 b_1, ..., a_n b_n}$; $#da + #db =  diag{a_1 + b_1, ..., a_n + b_n}$ $k #da = diag{k a_1, ..., k a_n}$

== 初等矩阵
由单位矩阵经过一次初等变换，得到的矩阵，称为#highlight()[初等矩阵]，联想我们前面所讨论的矩阵三个初等行变换：1. 行交换， 2. 行倍乘 3. 行倍加。

=== 三个基本初等矩阵
#let j =$j$; #let i = $i$; #let k = $k$
将#idef 的#j 行的#k 倍加到#i 行上，记作$P(i, j(k))$, 表示为:
$P(i, j(k)) = mat(1,0,0,...,0,0, 0,0; ...; 0,0,..., 1, ..., k,...,0;...;0,0,...,0,...,1,...,0;...;0,0,...,...,...,...,...,1) <- r_j times k + r_i
$;

将#idef 的#i 行 乘以#k， 记作$P(i(k))$，表示为:
$P(i(k)) = mat(1,0,...,...,0; ...; 0,0,...,k,...; ...; 0,0,...,...,1) <- r_i times k
$

将#idef 的#i 行 #j 行交换，记作$P(i,j)$，表示为:
$P(i, j) = mat(1,0,..., ..., ..., ..., 0;...; 0,...,0,...,1,...,0; ...;0,...,1,...,0,...,0;...; 0,...,0,...,0,...,1;) <- r_i r_j 交 换
$

初等矩阵将矩阵乘法和矩阵的初等行变换联系了起来:

=== 定理 $A_(#sn)$ 左乘以一个$s$阶初等矩阵，等价于对#A 做一次 初等行变换； #A 右乘以一个$n$阶初等矩阵，就相当于#A 做一次初等列变换
下面只证明前半部分
#let avec = $vec(#ba _1, #ba _2, ..., #ba _s)$
我们把#A 写成行向量形式， 则$A=mat(#ba _1, #ba _2, ..., #ba _s) ^T$. 那么$P(i(k))A$就是:
$mat(1,0,...,...,0; ...; 0,0,...,k,...; ...; 0,0,...,...,1)vec(#ba _1, #ba _2, ..., #ba _s)= vec(#ba _1, #ba _2, ..., #ba _k, ..., #ba _s) <- k times #ba _k
$. 那么$P(i, j(k))A = mat(1,0,0,...,0,0, 0,0; ...; 0,0,..., 1, ..., k,...,0;...;0,0,...,0,...,1,...,0;...;0,0,...,...,...,...,...,1) #avec = vec(#ba _1, #ba _2, ..., #ba _k + k times #ba _j, ..., #ba _j, ..., #ba _s) <- #ba _k + k #ba _j$, $P(i,j)A = mat(1,0,..., ..., ..., ..., 0;...; 0,...,0,...,1,...,0; ...;0,...,1,...,0,...,0;...; 0,...,0,...,0,...,1;)  #avec = vec(#ba _1, ..., #ba _j, ..., #ba _i, ..., #ba _s) <- #ba _i #ba _j 交 换$，定理前半部分得证

这个定理也可以反过来叙述，对#A 做初等行变换，等价于#A 左乘以一个初等矩阵， 对#A 做列变换，就等价于右乘以一个初等矩阵 （反过来证明其实稍微复杂一点），这里主要表示两者等价

== 上下三角矩阵
主对角线下方全为0的矩阵,即$a(i, j) = 0, (i >j)$，叫做上三角矩阵。很显然，两个上三角矩阵的和仍然是上三角矩阵，一个上三角矩阵乘以数量$k$，仍然是一个上三角矩阵。

=== 命题， 两个n阶上三角矩阵#A #B 的乘积仍然是上三角矩阵，并且$A B$主对角线上的元素等于#A  #B 对应的主对角元乘积
证明:
$(A_(n) B_(n))_(i, j)=  sum_k a_(i k) b_(k j), 若 要 a_(i k)b_(k j) != 0 => i <= k, k <= j. $， 设$i > j$ 则$cases(a_(i,k) = 0 \, 1 <= k < i, b_(k j) = 0 \, i  <= k <= n (because i > j -> b(k, j) = 0))$ 从而对于任意$i>j$， 乘积对应的元素均为0，从而#A #B 仍然是上三角矩阵。

后半部分不证了，留作以后复习的时候证明

主对角上方的元素全为0的方阵称为下三角矩阵。对应于$a(i, j)=0, i < j$ 下三角矩阵性质和上三角性质类似

== 对称矩阵（略）
这两个部分个人目前认为不重要，后面用到了再来学习
== 斜对称矩阵 (略)

= 矩阵乘积的秩、行列式和方阵的迹
#let rank =$r a n k$
== 定理 $rank(A B) <= min {rank(A), rank(B)}$
回忆 #rank 的定义:#highlight()[等于矩阵行向量组和或者列向量组的秩]。
那么根据矩阵乘法的三种表述形式中的后两种,即$A B$的每一个列向量$(A B)_j$ 是A的列向量组$#avecs$的线性组合，从而$rank(A B) <= rank(A)$, 同理，$A B$的每一个行向量都是#B 的行向量的线性组合，从而$rank(A B) <= rank(B)$ ，综合，$rank(A B) <= min(rank(A), rank(B))$. Q.E.D

=== 是$A_(#sn)$ 是实数域上的一个矩阵，那么:$rank(A^' A) = rank(A A^') = rank(A)$
#let beta=$bold(eta)$
由上定理$rank(A^' A) <= min {rank(A^'), rank(A)} -> rank(A^' A) <= rank(A)$ 可见该定理不能直接证明相等关系。接下来我们从线性方程组的解的角度出发求证:
#let AT=$A^'$;#let betaT = $beta^'$
1. 设$beta$ 是$A #bx = #b0 $的一个解，那么$#AT A beta= #AT #b0 = #b0$, 从而#beta 是 方程$(#AT A)#bx = #b0$ 的一个解
2. 设$beta$ 是$#AT A #bx = #b0$的解，那么两边同时左乘#betaT, $betaT #AT A #bx = 0 = > (A beta)^' (A beta) = 0 <- 此 处 是 实 数 0$，设$A beta = vec(c_1, c_2, ..., c_n) => (A beta)^' (A beta) = sum_k c_k^2 = 0 => c_k = 0, 1 <= k <= n$, 从而#beta 也是$A #bx = #b0$ 的一个解

\1. 表明，$#AT A #bx$ 的解一定可以在$#A #bx$的解空间中，\2. 表明，$#A #bx$ 的解一定在$#AT A #bx$ 的解的空间中，从而两者同解（解空间维数相等），从而它们的秩相等。对于复数域上的矩阵，$sum_k c_k^2 = 0 $ 不能得出$ c_k = 0$

#let nn = $n times n$
== 定理 设$A_(#nn), B_(#nn)$, 则 $|A B| = |A||B|$
为了构造$|A||B|$, 可以构造这样的矩阵$mat(A, b0; -#idef, B)$ 该矩阵的行列式为$|A||B|$, 接下来我们对这个矩阵进行初等行变换:
$
mat(A, b0; -#idef, B) = mat(a_11, a_12, ..., a_(1 n), 0,0,...,0;a_21, a_22, ..., a_(2 n),0,0,...,0;...;a_(n 1), a_(n 2), ..., a_(n n), 0,0,...,0;-1, 0, ...,0, b_11, b_12, ..., b_(1 n); 0, -1, ...,0, b_21, b_22, ..., b_(2 n);...; 0, 0, ...,-1, b_(n 1), b_(n 2), ..., b_(n n)) =>^(1) mat(0, 0, ..., 0, sum_k a_(1 k) b_(k 1), sum_k a_(1 k) b_(k 2),..., sum_k a_(1 k) b_(k n);a_21, a_22, ..., a_(2 n),0,0,...,0;...;a_(n 1), a_(n 2), ..., a_(n n), 0,0,...,0;-1, 0, ...,0, b_11, b_12, ..., b_(1 n); 0, -1, ...,0, b_21, b_22, ..., b_(2 n);...; 0, 0, ...,-1, b_(n 1), b_(n 2), ..., b_(n n))
$

这里重点解释一下第一步，即消去#A 的第一行，首先，我们消去$mat(A, b0; -#idef, B)$  中的 $a_11$,消除方法是，用$A + -#idef _(r 1) * a_11$, 对应于$b0$ 的第一行就变成$(a_11 b_11, a_11 b_12, ... a_11 b_1n )$, 接下来校区$a_12$, 方法是$A + -#idef _(r 2) * a_12$, $b0$ 的第一行就变成$(a_11 b_11 + a_12 b_21, a_11 b_12 + a_12 b_22, ... a_11 b_1n + a_12 b_2n )$，依次类推可得，完全消去#A 的第一行，则#b0 的第一行就变成$(sum_k a_(1 k) b_(k 1), sum_k a_(1 k) b_(k 2),..., sum_k a_(1 k) b_(k n))$, 这个乘积可以看做$ba_1 B,  A = avecs^T$. 我们在消去过程中，构造了这个乘积。因为$ba_1$的任意一列$k$的元素消去时，只需要选择$- idef_(r_k) * a_k + A $即可，对应于#B 也是第$B_(r_k) * a_k$, #b0 部分则是$B_(r_k) * a_k + #b0$. 前面说过$bold(alpha)^T B$的结果就是#B 的各行向量以$bold(alpha)^T$的各分量为系数做线性组合。此处同理。

依此类推，我们很容易可以将上面的矩阵化作:
$
mat(0, 0, ..., 0, sum_k a_(1 k) b_(k 1), sum_k a_(1 k) b_(k 2),..., sum_k a_(n k) b_(k n);a_21, a_22, ..., a_(2 n),0,0,...,0;...;a_(n 1), a_(n 2), ..., a_(n n), 0,0,...,0;-1, 0, ...,0, b_11, b_12, ..., b_(1 n); 0, -1, ...,0, b_21, b_22, ..., b_(2 n);...; 0, 0, ...,-1, b_(n 1), b_(n 2), ..., b_(n n)) => mat(0, 0, ..., 0, sum_k a_(1 k) b_(k 1), sum_k a_(1 k) b_(k 2),..., sum_k a_(1 k) b_(k n);0, 0, ..., 0,sum_k a_(2 k) b_(k 1), sum_k a_(2 k) b_(k 2),..., sum_k a_(2 k) b_(k n);...;0, 0, ..., 0, sum_k a_(n k) b_(k 1), sum_k a_(n k) b_(k 2),..., sum_k a_(n k) b_(k n);-1, 0, ...,0, b_11, b_12, ..., b_(1 n); 0, -1, ...,0, b_21, b_22, ..., b_(2 n);...; 0, 0, ...,-1, b_(n 1), b_(n 2), ..., b_(n n)) = mat(b0, A B; -idef, B)
$
根据拉普拉斯定理，$mat(b0, A B; -idef, B)$ 的行列式就是$|A B|$；而矩阵的初等行变换的行倍加（参考行列式性质7.）不会改变矩阵的行列式，从而$|A B| = |A| |B|$

这个定理可以根据数学归纳法推广到任意各n阶矩阵相乘
$
|A_1A_2...A_n|= |A_1||A_2|...|A_n|
$

== 定理 比内-柯西公式
略

== 方阵的迹
n阶方阵的主对角线元素之和称为A的迹，记作T, 即:$T_r(A) = sum_i a_(i i)$ 
性质略
= 可逆矩阵（噩梦系列）
#set math.equation(numbering: "(1)", supplement: [式])
#let bk = $bold(K)$
对于数域#bk 上的矩阵#A，如果存在#bk 上的矩阵#B 使得 $ A B = B A = I $ <aa>, 则称#A 是可逆的矩阵（或者非奇异矩阵).

根据 @aa , 设$A_(#sn), B_(#nm)$, 则易知$s = m$, 同理，由$B A = I = A B => s = n => $ #A 是一个n 阶方阵，同理B也时一个n 阶方阵。
== 定理1. 如果#A 可逆，则#A 的逆矩阵唯一
设$B_1$ 是A的逆矩阵，$B_2$ 是A的另外一个逆矩阵，从而有$B_1 = B_1 #idef = B_1 A B_2 = #idef B_2 = B_2$, 从而其逆矩阵唯一

== 定义2. 逆矩阵
#let inva = $A^(-1)$
@aa 中的 #B 称为A的逆矩阵，记作$A^(-1)$, 根据定义$ A inva = inva A = #idef $ <bb> ， 并且$(inva)^(-1) = A$. 由@bb 可知#A 可逆的必要条件是$|A| != 0$ （由矩阵乘积的行列式定理可得）
#let BA=$bold(A)$
#let BAS=$mat(BA_(1, 1), BA_(2,1), ..., BA_(n, 1);BA_(1, 2), BA_(2,2), ..., BA_(n, 2);...; BA_(1, n), BA_(2,n), ..., BA_(n, n);)$
#let BAStar=$BA^(*)$
当$|A| != 0$时，设$A=a_(i,j)$,$BA_(i j)$ 是$a_(i j)$的代数余子式，那么我们构造一个这样的矩阵
$
A BAS
= mat(a_11, a_12, ..., a_1n;a_21, a_22, ..., a_2n;...; a_(n 1), a_(n 2), ..., a_(n n)) BAS = BAStar
$ <cc>
由行列式性质可知，乘积矩阵$C_(i, i) = sum_k a_(i, k) BAStar_(k, i) = sum_k a(i, k) BA_(i,k) = |A|$。而$i != j, C_(i,j) = sum_k a_(i,k)BA_(j,k)$, 由行列式性质5（第i行元素与第k行对应元素未知的代数余子式乘积之和为0，$i!=k$）, 因此 @cc 就可以写作:
$
A BAStar = mat(|A|, 0, 0, ..., 0; 0, |A|, 0, ...,0;...;0,0,0,..., |A|) = |A| #idef.
$ <cc2>
一般把#BAStar 称作#A 的伴随矩阵。同样的，我们也可以得到$BAStar A = |A| #idef$.

=== 矩阵可逆定理
数域#bk 上的#highlight()[n阶方阵（一定是方阵）]，可逆的充要条件是$|A| != 0$.并且如果$A$可逆，其逆矩阵为$inva = 1/(|A|)BAStar$.

证明:
1. 必要性:$A inva = I = > |A inva| = |A| |inva| = 1 => |A| != 0$
2. 充分性:$|A| != 0$, 由@cc2 可以知道,$frac(1, |A|)BAStar A = 1/(|A|) |A| I = I; A(1/(|A|)BAStar) = 1/(|A|) A BAStar = I => inva = 1/(|A|) BAStar$

根据矩阵可逆定理，可以得到一些推论，#BA 可逆时，可以得出$|A| != 0 <=> rank(A) = n <=>$ #BA 的行列向量线性无关 $<=>$ #BA 的行列向量是向量空间$K^n$的一个基 $<=>$ #BA 的行列空间都等价于$K^n$

=== 命题 设 $A, B$ 是数域K上的n阶矩阵，并且满足$ A B = #idef$, 那么 #A  #B 都是可逆矩阵，并且$#inva = B$, $B^(-1) = A$.
证明:
1. 因为$A B = #idef => |A| != 0, |B| != 0$, 从而$A, B$都是可逆矩阵
2. $A B = #idef$, 两边同时*左乘* $inva$, 得到$inva A B = inva => B = inva$, 同理可证另外一个

// TODO 编写函数写逆矩阵
=== 性质 1. 单位矩阵可逆，并且$I^(-1) = I$

=== 性质 2. 如果$A$ 可逆，那么$inva$ 也可逆，并且$(inva)^(-1) = A$
#let invb = $B^(-1)$
=== 性质 3. 如果 $A, B$ 可逆，那么$A B$也可逆，并且$(A B)^(-1) = B^(-1) A^(-1)$

证明:
1. $|A B| =|A||B|, because |A| != 0, |B| != 0, => |A B| != 0 =>$ $A B$可逆
2. $(A B)(invb inva) = A #idef inva =  A inva = #idef; (invb inva)(A B)= invb B = #idef$

利用数学归纳法, 如果$A_1, A_2, ..., A_s$ 可逆, 那么$A_1A_2...A_s$ 也可逆，并且其逆是$A_s^(-1)A_(s-1)^(-1)...A_1^(-1)$

#let ta = $A^(')$
=== 性质4， 如果$A$可逆，则$ta$ 也可逆，并且$ta^(-1) = (inva)^(')$
证明：
$ta (inva)^(') = (inva A)^(') = idef^(') = idef$ (根据矩阵乘积的转置关系可得)， 即转置的逆等于逆的转置

=== 性质5, 矩阵$A$ 可逆的充要条件是其可以表示成一系列初等矩阵的乘积
1. 必要性: 如果$A$可逆，则$A$ 一定是满秩矩阵，则其可以经过一系列初等行变换化为简化阶梯型, 而满秩矩阵的简化阶梯型就是$idef$, 从而$A$ 可以初等行变换为$idef$。 根据前述定理，矩阵初等行变换，等于左乘以一系列初等矩阵，即:$(P_i ... P_(2) P_1)A = idef => A = (P_i ... P_2 P_1)^(-1)$. 

=== 性质6. 矩阵 #A 左乘或者右乘一个可逆矩阵，#A 的秩不变
根据性质5，设#B 可逆，则#B 可以表示为一系列初等矩阵的乘积，而#A 和一些列初等矩阵相乘等价于做初等行变换或者列变换，其秩不会发生变化。

== #highlight()[总结:秩/行列式/可逆的关系]
1. 秩定义为矩阵的列或者行向量组的极大无关组的向量个数（或者向量组的秩），矩阵的秩不仅是定义在方阵上的
2. 行列式最重要的不是其定义(如何计算)，但是要注意行列式仅定义在`方阵上`，而是其是否为0，一个矩阵我们可以化成阶梯型或者简化阶梯型$J$，其行列式的`绝对值`等于$J$ 对角线的元素的乘积
3. 矩阵的秩对应于阶梯型中的主元的个数, 从而，对于一个方阵而言, 如果满秩$<=>$$J$对角线元素全不为0$<=>$行列式不为0

4. 可逆矩阵一定是方阵，因此其具备行列式，而前面的可逆矩阵定理证明了，可逆矩阵的行列式必不为0，从而其也必是满秩矩阵

= 矩阵分块
一些大的矩阵，我们可以看成若干个小的矩阵的组合，比如:$A=mat(1,0,0, 2,5;0,1,0,3, -2; 0, 0, 1, -1, 6;0,0,0,4,0;0,0,0,0,4)= mat(I_3,B;#b0, 4I_2)<- 按 行 列 划 分$, 其中$B = mat(2,5;3,-2;-1,6)$。组成A的小矩阵称为矩阵的分块，A称为分块矩阵。

分块矩阵可以利用大矩阵中的局部的性质，使得运算变得简单(主要是矩阵乘法)

对于$A = mat(a_11, a_12, a_13; a_21, a_22, a_23; a_31, a_32, a_33;), B = mat(b_11, b_12, b_13, b_14;b_21, b_22, b_23, b_24;b_31, b_32, b_33, b_34;b_41, b_42, b_43, b_44;)$， 可以按照$A_11 = mat(a_11, a_12), A_12 = mat(a_13); A_21=mat(a_21, a_22; a_31, a_32;), A_22 = mat(a_23; a_33). B_11=mat(b_11;b_21;) B_12 = mat(b_12;b_22;), B_13 = mat(b_13, b_14;b_23, b_24;),B_21 = mat(b_31), B_22 = (b_32), B_23 = mat(b_33, b_34);$ 从而$A=mat(A_11, A_12; A_21, A_22), B = mat(B_11, B_12, B_13; B_21, B_22, B_23)$
按照矩阵乘法的定义，我们使得这些分块矩阵相乘:$(A B)_(i j) = sum_k A_(i k) B_(k j)$ 注意这里有一个很重要的限制是，这些分块的小矩阵可以相乘。

== 矩阵划分
我们把一个矩阵$A_(e times f)$划分成$(M+1) times (N+1)$个小矩阵，则该矩阵按行要选定$(M)$个行 分割，列需要选定$(N)$个列分割，设选定的行分别是$(s_1, s_2, ...,s_M)$, 选定的列分别是$(j_1, j_2, ..., j_N)$，这些行列将原矩阵分解为$(M + 1) times (N+1)$个小矩阵，$A_11 = (s_1 - 0) times (j_1 - 0),  A_12 = (s_1 - s_0 ) times (j_2 - j_1), A_21 = (s_2 - s_1) => A_(k p) = (s_k - s_(k-1)) times (j_p - j_(p-1)), 1<=k<=M+1, 1<= p <= N+1, s_0 = j_0 = 0, s_(M+1) = e, j_(N+1) = f$

对于矩阵$B_(f times g)$, 也进行类似划分，将这些小的矩阵分块当做一个单元，那么#B 的划分应当满足矩阵乘法的要求，即B的分块至少有(N+1)行，那么还有一个问题是，即便是选定$N$个行去分割B，这些行能否和A矩阵的分块相乘呢?我们注意到$A_11$ 是一个$(s_1 times (j_1))$的矩阵，因此$B_(1, k)$ 必须是$(j_1 times ?)$的矩阵，同理，$A_12 = [(s_1) times (j_2 - j_1)]$， 这要求$B(2, k) = [(j_2 - j_1) times ?]$。由于左矩阵的第$k$列的单元 总是和 右矩阵的第$k$行的单元相乘，从而就可以得出，$A_(?, k)$的列数总是要和$B_(k, ?)$的行数相等，前者由$(j_1, j_2, ..., j_N)$决定，设B的分割行为$(r_1, r_2, ..., r_N)$(前文可知两者总数必须相等)， 并且有$r_1 = j_1, r_i - r_(i - 1) = j_i - j_(i-1) ==>^(数 学 归 纳 法) r_i = j_i$ 
即#B 也必须按照#A 的列划分方式分割行

矩阵分块以后，我们按照矩阵乘法来看待以这些小矩阵作为单元的乘积#C， #C 的每个单元是#A #B 的分块的乘积，将#C 的单元视作矩阵展开时，他和#A #B 直接相乘的结果是否相等呢？答案是肯定的，不过证明他时，描述的方法不太一样。前面的内容主要从如何对矩阵分块出发讨论。

== 定理 设#A #B, A 的行分解成 $u$ 组， 第#i 组有$s_i$行，A的列分解成$t$组，第$j$组有$n_j$列，#B 的行划分和 #A 的列划分一直， #B 的列 划分成$v$ 组， 第$l$ 组有$m_l$列。 则分块矩阵A和B的乘积，与 A B直接的乘积是相等的

证: 略  以后有时间的时候证明

#let bvecs=$(bold(b)_1, bold(b_2), ..., bold(b_m))$
#let avecs=$(ba_1, ba_2, ..., ba_s)$
=== 命题1. 设$A_(#sn), B_(#nm)$, 并且设B的列向量表示为$#bvecs$, 则$A B = (A#bb _1, A#bb _2, ..., A#bb _m)$ 
证明：
B以列向量表示时，相当于将所有行划分为一组，那么按照定理，#A 的列划分也要变成所有列划分成一组，此时#A 可以表示为行向量形式$#avecs$; #B 每一列都单独划分出一个矩阵，即#B 的行的划分法为$v_i = 1$. A B 的乘积就等价于A 和 B的各分块矩阵的乘积，按照分块矩阵乘法定义，$A B  = #avecs ^' #bvecs = mat(ba_1 bb_1, ba_1 bb_2, ..., ba_1, bb_m; ba_2 bb_1, ba_2 bb_2, ..., ba_2, bb_m;...; ba_s bb_1, ba_s bb_2, ..., ba_s, bb_m;)$, 乘积矩阵的列向量$bold(p r o _j) = #avecs ^'  bb_j = A b_j, 1 <= j <= m => A B = (A#bb _1, A#bb _2, ..., A#bb _m)$

=== 推论1. 设$A_(#sn) != b0, B_(#nm) = bvecs$,则, 若$A B = b0 => bvecs$ 均是$A bx = b0$的解 (结论显然)

#let bc = $bold(c)$
#let cvecs = $(bc_1, bc_2, ..., bc_m)$

=== 推论2. 设$A_(#sn) != b0, B_(#nm) = bvecs， C=cvecs, A B = C =>$, $bb_i in bvecs$ 是 $A bx = bc_i $的一个解

=== 分块矩阵的初等行变换、列变换
略

= 正交矩阵和欧式空间
#let ta = $A^(')$
在直角坐标系中，我们可以选定两个不共线向量$ba = (x_1, y_1), bb = (x_2, y_2)$，因他们不能互相表示，因此它们是平面坐标系的一个基，将他们以列向量形式组成一个矩阵$A = mat(x_1, x_2; y_1, y_2)$, 因为#ba #bb 不共线，因此该矩阵是一个满秩矩阵，从而其可逆。
当#ba #bb 互相正交且为单位向量时，则有$x_i^2 + y_i^2 = 1, i = 1, 2; ba bb = 0 = x_1x_2 + y_1y_2 = 0 => inva A = mat(x_1, y_1; x_2, y_2) mat(x_1, x_2; y_1, y_2)  = mat(1, 0;0, 1) = #idef$, #A 的列向量互相垂直，且其模为1，很自然的，我们就把这样的矩阵称为正交矩阵.

== 定义1 正交矩阵
如果n 阶矩阵#A 满足:
$
  ta A  = #idef
$
那么称#A 是正交矩阵。 我们从定义可以得出, 若#A 是正交矩阵:
1. $ta A = idef$
2. #A 可逆，且$inva = ta$
3. $A ta = idef$

== 正交矩阵的性质
=== 性质1. $idef$ 都是正交矩阵

=== 性质2. 如果#A #B  是正交矩阵，则$A B$ 也是正交矩阵
证明:
$(A B)^(') A B = B^(') A^(')A B$ 因为 #A #B 是正交矩阵，所以 $B^(') A^(')A B = B^(')idef B = idef => A B$也是正交矩阵

=== 性质3. 如果#A 是正交矩阵，则#inva 也是正交矩阵

=== 性质4 如果A是正交矩阵，则$abs(det A) = 1$
证明:
$
det(ta A)= |ta||A| = (det(A))^2 = det(idef) = 1 => abs(det(A)) = 1
$

=== 命题1. 
#let avecs = $(ba_1, ba_2, ..., ba_n)$; #let bvecs = $(bb_1, bb_2, ..., bb_n)$
设#A 为n阶矩阵，其行向量为$avecs^'$, 列向量为$bvecs$, 那么
1. #A 为正交矩阵，当且仅当#A 的行向量组满足:$cases(ba_i ba_j^(') = 1 \, i=j, ba_i ba_j^' = 0 \, i!=j)$.
2. #A 为正交矩阵，当且仅当#A 的列向量组满足:$cases(bb_i bb_j^(') = 1 \, i=j, bb_i bb_j^' = 0 \, i!=j)$.

证明:
$
A ta = vec(ba_1, ba_2, ..., ba_n) bvecs = idef => C_(i j)= sum_k a_(i k) a_(k j) => cases(sum_k a_(i k) a_(k i) = 1, 0 \, e l s e) => \
cases(ba_i ba_i^' = 1, 0 \, e l s e) 
$  从而 1 得证。

2的证明过程类似。

== 定义2. 内积
#let balp = $bold(alpha)$
#let bbet = $bold(beta)$
我们把定义在$R^n$上的两个向量$balp = avecs$, $bbet = bvecs$, 其内积(标准内积)定义为:
$
 (balp, bbet) =^(d e f) sum(a_i b_i)
$
这是一个关于向量#balp #bbet 的实函数。该式也可以写作:$(balp, bbet) = balp bbet^'$
=== 性质1. 对称性 $(balp, bbet) = (bbet, balp)$
证明: 

按照定义展开:$(balp, bbet) = sum_i a_i b_i = sum_i b_i a_i = (bbet, balp)$
=== 性质2. 线性性质1 $(ba + balp, bbet) = (ba, bbet)+ (balp, bbet)$
证明:
按照定义展开:设$ba = (k_1,k_2,...,k_n)$, $(ba + balp, bbet) = sum_i (a_i + k_i)b_i = sum_i a_i b_i + sum_i k_i b_i = (ba, bbet)+ (balp, bbet)$
=== 性质3. 线性性质2 $(k balp, bbet) = k(balp, bbet)$
按定义展开可直接得出
=== 性质4. 正定性 $(balp, balp) >= 0$，且等号成立时当且仅当$balp = b0$
按定义,$(balp, balp) = sum_i a_i^2 >= 0$, 显然，当$a_i = 0$时， 等号成立

综合性质2、性质3，向量内积是满足线性的。

#let brn = $R^n$
== 定义3. 欧几里得空间
n 维向量空间$R^n$ 有了标准内积后，我就把它称作一个#highlight()[欧几里得空间]。 

欧式空间中，我们把向量#ba 的长度规定为:$|ba| =^(d e f) sqrt((ba, ba))$,长度为1的向量称为单位向量。显然单位向量满足$(a, a) = 1$. 同时对于$k ba, |k ba| = abs(k) abs(ba)$, 对于任意$ba != b0, 1/abs(ba) ba$一定是单位向量, 我们可以利用这个公式将任意非0向量单位化.

在欧式空间中，如果$(ba, bb) = 0$, 那么称$ba,bb$是正交的，记作$ba perp bb$. 显然$b0$和任何向量都正交

在欧式空间中，向量组$avecs, ba_i != b0$ 满足两两互相正交，即$(ba_i, ba_j) = 0, i != j$. 我们把它称为正交向量组。如果只有一个非0向量构成的向量组也是正交向量组。

如果正交向量组中的每个向量都是单位向量，那么我们把它称为正交单位向量组。

=== 命题 欧式空间中，正交向量组一定线性无关
设向量组$avecs$ 是正交向量组, 再设$k_1 ba_1 + k_2 ba_2 + ... + k_n ba_n = b0$ 那么$(k_1 ba_1 + k_2 ba_2 + ... + k_n ba_n, ba_i) = (b0, ba_i) = 0, ba_i in avecs$，而$(k_1 ba_1 + k_2 ba_2 + ... + k_n ba_n, ba_i) = sum_j k_j ba_j ba_i^' + k_i ba_i ba_i^' = 0, j != i => k_i (ba_i, ba_i) = 0, because ba_i != b0 => k_i = 0$， 因此正交向量组线性无关

由该命题可知，$R^n$ 中的 n个向量组成的正交向量组一定是$R^n$的一个基， 我们称为#highlight()[正交基], 如果这个向量组是正交单位向量组，则称为#highlight()[标准正交基]

=== 命题 $R^n$ 上，#A 是正交矩阵的充要条件是#A 的行或列向量组是$R^n$的一组标准正交基
证明:
由正交矩阵定义可知，#A 是正交矩阵时,$ba_i ba_i^' = 1; ba_i ba_j^' = 0, i!=j$, 即各行向量的长度为1, 并且#A 的行向量组是正交向量组(两两正交), 从而它是$R^n$的一组标准正交基

列向量组证明类似

=== 定理 正交向量组构造定理

设$avecs$ 是欧式空间#brn 中的一个线性无关向量组，令$
bb_1 = ba_1 \
bb_2 = ba_2 - ((ba_2, bb_1))/((bb_1, bb_1)) bb_1 \
... \
bb_n = ba_n - sum_(k=1)^(n-1)((ba_n, bb_k))/((bb_k, bb_k))bb_k
$
则$bvecs$ 是正交向量组，且它和$avecs$等价

证明:
使用数学归纳法证明，容易验证，$n=2$时成立，现在假设，$n=N$时成立，我们证明$n=N+1$时也成立

= 矩阵的特征值和特征向量（IMPORTANT）
== 矩阵特征值定义
#let lam = $lambda$
对于数据K上的n阶方阵，如果存在一个数$lam_0 in K$, 存在一个向量$#ba in K^n, #ba != #b0$, 使得,$A #ba = lam_0 #ba$,则$lam_0$ 称为A的一个特征值, #ba 称为A的属于$lam_0$的一个特征向量

显然，如果#ba 是A的属于$lam_0$的一个特征向量，则$k ba, forall k!=0 => A(k#ba)= k (A #ba) = k (lam_0 #ba) = lam_0 (k #ba)$， 即$k ba$也是A的属于$lam_0$的一个特征向量。

我们把矩阵看做一种变换，特征向量和特征值的含义就是，特征向量在矩阵A的变换下，以特征值做尺度变换，变换前后一定是共线的。某些情况下，矩阵变换一定会使得向量不共线（比如不是$n pi$的旋转）. 换句话说，矩阵的特征向量反映了矩阵在某些"方向上"的特殊作用.

矩阵的特征值、特征向量的概念十分重要，主成分分析、特征值分解等都需要利用特征向量。



== 矩阵特征值和特征向量的求解与判定

设#A 是一个n阶矩阵，#lam 是一个变量，则行列式$|lam idef - A| = mat(delim:"|", lam - a_11, -a_12, ..., -a_(1 n); ..., -a_(n 1), -a_(n 2), ..., lam - a_(n n))$ 称为#A 的#highlight()[特征多项式]， 接下来说明如何求解或判定特征值以及特征向量

设$lam_0$是A的一个特征值，#ba 是A的属于$lam_0$的一个特征向量，从而:
$
A#ba = lam_0 #ba, lam_0 in K, #ba in K^n, #ba != #b0 =>^(两 边 同 减 去 A#ba) #b0 = lam_0#ba - A#ba = (lam_0 idef #ba  - A#ba) = (lam_0 #idef - A)#ba = #b0 , #ba != #b0
$
从而#ba 是齐次方程组$(lam_0 idef - A)#bx =#b0$的一个非0解，这要求系数矩阵$(lam_0 idef - A)$的行列式必为0，这进一步要求$lam_0$是A的特征多项式$|lam idef - A| =0$的一个解。如果该多项式没有解，说明行列式必不为0，从而矩阵便不存在特征值和特征向量。

我们回忆齐次线性方程组的解集结构:将所有自由变量分别取1， 其余分量写成这些变量的表达式，这些解就构成了齐次线性方程组解的空间的一个基。

在$(lam_0 idef - A)#bx = #b0$ 有解的情况下，其解的空间的所有非0向量都是A 的属于$lam_0$的特征向量

这样可以总结求特征值和特征向量的步骤：
1. 求矩阵的特征多项式的根
2. 对于每一个根$lam_0$，求解其构成的齐次线性方程组的基础解系
3. 基础解系所张成的空间中的所有非0向量，都是矩阵的属于$lam_0$的特征向量
