#set text(
  font: "New Computer Modern",
  size: 6pt
)
#set page(
  paper: "a5",
  margin: (x: 1.8cm, y: 1.5cm),
)
#set par(
  justify: true,
  leading: 0.52em,
)
// 定义 计数器，自定义
#let theorem_counter=counter("theorem")
#theorem_counter.update(1)
= 行列式引入
线性方程组求解时，曾说过可以通过方程组的增广矩阵化简成阶梯型来分析判定该方程组解的情况，但这已经接近于求出方程组的解了，所以需要别的方法来从方程组的系数矩阵或者增广矩阵入手直接判定该方程组解的情况，这就引入了行列式
== 二阶行列式
考虑二元一次方程组:
$
cases(
  a_(11)x_1 + a_(12)x_2 = b_1,
  a_(21)x_1 + a_(22)x_2 = b_2
)
$
其增广矩阵为:
$
mat(a_(11), a_(12), b_1;
a_(21), a_(22), b_2) => \
mat(a_(11), a_(12), b_1;
0, a_(22)-  a_21/a_(11) a_(12), b_2 - a_(21)/a_(12) b_1)
$
当(设$a_(11)!=0$):
$
cases(
  a_(22) - a_21/a_(11) a_(12) != 0 方 程 组 有 唯 一 解,
  a_(22) - a_21/a_(11) a_(12) = 0 方 程 组 有 无 穷 多 解，或 无 解
) \
a_(22) - a_21/a_(11) a_(12) = 0 => a_(11)a_(22) - a_(21)a_(12) = 0
$
所以二元一次方程组解的判别，就可以使用$a_(11)a_(22) - a_(21)a_(12)$ 是否为0来判定。注意到$a_(11)a_(22)$ 的列标号$1, 2$是数1,2的一个排列。

== n元排列
n 个自然数（互不相同）可形成的排列为$n!$个，当其从小到大排列时，称为n元排列的自然序
n 元排列的一个排列我们记作
=== 逆序
以数`range(5)`为例，其自然序为`12345`, 调换末尾位置:`12354`，则 5 4 不是从小到大排列的，称其为逆序对，一个排列的逆序对数称为该排列的逆序数，记为$tau$
如
$
12345 -> 逆 序 数 为 0 ;tau(12345) = 0\
12354 -> 逆 序 数 为 1 \
12534 -> 逆 序 数 为 2
$
编写程序判定排列逆序数:
```py
def get_inverse_order(nums:list):
  cnt = 0

  for idx in range(len(nums)):
    for j in range(idx + 1, len(nums)):
      if nums[idx] > nums[j]:
        cnt += 1
  return cnt

```
一个排列的逆序数如果是偶数，成为偶排列；如果是奇数，称为奇排列

定理#theorem_counter.display(). 
`如果交换一个排列中的任意两个元素，则排列的奇偶性会发生变化`

证明:

设有排列:$a_0,a_1, ..., a_i, a_j, ..., a_n$， 设$a_i<a_j$交换$a_i, a_j$ 则排列变为 $a_0,a_1, ..., a_j, a_i, ..., a_n$, 则与$a_0, a_1, ..., a_(i-1)$ 与 $a_i, a_j$的逆序关系没有改变，同理，$a_i, a_j$与$a_(j+1), ..., a_(n)$的逆序关系，也没改变，只有$a_i, a_j$发生了调换，其逆序数+1.而+1 会改变排列的奇偶性

对于任意的情形，可以考虑从上述证明中的相邻元素逐步交换而来，即$a_j$逐步换到$a_i$的位置，经过$j-i$步骤，而此时$a_i$ 被换到 $a_(i+1)$的位置，则将$a_(i+1)$换到原$a_j$位置需要经过$j-i-1$步，总共需要$2(j-i) - 1$ 步（奇数），奇数次调换对应于奇偶性变化，则排列奇偶性改变

#theorem_counter.step()
定理#theorem_counter.display() . `n元排列可以由自然序1,2, ...,n 经过K次变换而来，那么该排列的奇偶性与K的奇偶性相同`

证：偶数次对换不改变奇偶性，奇数次变换改变奇偶性，而自然序为偶排列，偶排列经过偶数次变换仍然为偶排列，...奇数...奇排列。*并且，一个奇数排列一定是要经过奇数次K变换才可得到，但K不唯一*，同理适用于偶排列。

例如 序列$132$ 可以由$123$调换$23$得到（1）次，也可以由$123->321->231->132$ 共3次变换得到

== n 阶行列式定义
了解了n元排列及2阶行列式后，我们可以给出n阶行列式定义

对于n阶`方阵`$A_n$,其行列式记作
$
det(A_n) = |A_n| = sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)...a_(n j_n)
$
其中$j_1,j_2,..., j_n$ 代表列指标的一个n元排列，上述的$sum$是对以列指标做的n元排列（共n!项）形成的元素乘积项求和，其中当列指标的n元排列为奇数时，排列前带负号，否则带正号，注意定义中可见行号是自然排序

例如，对于二阶行列式:
$
a_(11)a_(22) - a_(21)a_(12)
$
2列，共2项乘积项求和，其中第1项为$1,2$排列，为偶排列，带+,第2项为
$2, 1$，为奇排列，带负号

对于3阶方阵，求其行列式，先写出其排列$123, 132, 213, 231, 312, 321$, 其中$123, 231, 321$, 是偶排列， $312, 132, 213$是奇排列，所以其行列式就可以写作:
$
a_(11)a_(22)a_(33) + a_(12)a_(23)a_(31) + a_(13)a_(22)a_(31) - a_(13)a_(21)a_(32) - a_(11)a_(23)a_(32) - a_(12)a_(21)a_(33)
$
行列式中任意项都是不同行、不同列的元素相乘，只要其中任意1元素为0，则该项为0，如果一个n元方程组(n个方程)的增广矩阵可以化为有n个主元的形式，那么其对应的系数矩阵就可以化为一个上三角矩阵，形如
$
A = mat(
  a_(11), a_(12), a_(13), ..., a_(1n);
  0, a_(22), a_(23), ..., a_(2n);
  0, 0, a_(33), ..., a_(3n);
  ..., ...,...,...,...,;
  0, 0, 0, ..., a_(n n);
)
$
我们求这个上三角矩阵的行列式:
$
det(A) =  sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)...a_(n j_n)
$
对于上三角矩阵第n行的元素，$j_n < n -> a_(n j_n) = 0$，对于非自然序的排列$j_1, j_2, ... j_n$, 其行列式的项为$(-1)tau(j_1, j_2, ..., j_n) a_(1j_1)a_(2j_2)...a(n j_n)$,若要其中各元素不为0，则必须有$j_1 >= 1, j_2 >= 2, ..., j_n >=n$，满足此条件的取值只有$j_1 = 1, j_2 = 2, ..., j_n = n$。这个限定可以考虑用反证法以及递推证明

因此 上三角矩阵的行列式就是:
$
  a_(11)a_(22)...a_(n n) 
$
即对角线元素的乘积

上面的行列式定义是固定行指标为自然序，以列指标排序来定义的。当固定列指标为自然序，以行指标的排序来定义，同样适用。

构造行列式，行的自然顺序可以这么理解：从`1-n行，逐个取其某1列$j_k$的元素，从列取得时候不重复，即形成一个n元排列` --- ①

== 行列式的性质
=== 性质1. `n阶方阵的转置的行列式和原矩阵行列式相同`
$
|A^T|= |A|
$

证明, n阶方阵的转置行列式为:
#set math.mat(delim: "|")
$
mat(a_11, a_21, ..., a_(n 1);
a_12, a_22, ..., a_(n 2);
dots.v, dots.v, dots.down, dots.v;
a_(1 n), a_(2 n), ..., a_(n n)) = sum(-1)^tau(i_1,i_2,...,i_n)a_(i_1 1)a_(i_2 2)...a_(i_n n)
$
上式可以由行列式的定义直接得出，即从①得出
而又由行列式的行列定义等价性可知，上式也是原矩阵的行列式

由此可见,#highlight[就行列式而言，行列是等价的，对于行的性质，也可以应用于列]

=== 性质2. `若矩阵中某一行有公共系数k,则计算该行列式时，该数可以提出`
#set math.mat(delim: "[")
$A =mat(a_(11), a_(12), ..., a_(1n);
a_(21), a_(22), ..., a_(2n);
dots.v, dots.v, dots.down, dots.v;
K a_(k 1), K a_(k 2), ..., K a_(k n);
dots.v, dots.v, dots.down, dots.v;
a_(11), a_(12), ..., a_(1n);) ->$ 
#set math.mat(delim: "|")
$det(A) = K mat(a_(11), a_(12), ..., a_(1n);
a_(21), a_(22), ..., a_(2n);
dots.v, dots.v, dots.down, dots.v;
a_(k 1), a_(k 2), ..., a_(k n);
dots.v, dots.v, dots.down, dots.v;
a_(11), a_(12), ..., a_(1n);)$

证明:
仍然从行列式的定义出发，结合①
$det(A) &= sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)... [K a_(k j_k)]a_(n j_n) \
&= K sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)... a_(k j_k)a_(n j_n)
$

=== 性质3. 若矩阵A中的某一行，是矩阵B和C的和，并且矩阵B C除了该行外其他行和A相同，则$det(A) = det(B) + det(C)$
即
$
mat(a_(11), a_(12), ..., a_(1n);
a_(21), a_(22), ..., a_(2n);
dots.v, dots.v, ..., dots.v;
b_(k 1) + c_(k 1), b_(k 2) + c_(k 2), ..., b_(k n) + c_(k n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
)= 
mat(a_(11), a_(12), ..., a_(1n);
a_(21), a_(22), ..., a_(2n);
dots.v, dots.v, ..., dots.v;
b_(k 1) , b_(k 2), ..., b_(k n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);) + mat(a_(11), a_(12), ..., a_(1n);
a_(21), a_(22), ..., a_(2n);
dots.v, dots.v, ..., dots.v;
c_(k 1), c_(k 2), ...,  c_(k n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);)
$
证明:
依然从行列式的定义出发:

$det(A) &= sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)... [b_(k j_k) + c_(k j_k)] a_(n j_n)  \
&= sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)... [b_(k j_k) ] a_(n j_n) + \ & sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)... [c_(k j_k)] a_(n j_n) \
&= det(B) + det(C)
$

=== 性质4. A矩阵交换任意两行，行列式符号相反
证明：不妨设调换$m, k, m > k$行，则行列式为:
$
mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
a_(k 1), a_(k 2), ..., a_(k n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
) = sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)...[a_(m j_k)]...[a_(k j_m) ] a_(n j_n) 
$ -- 式1.

由于$m>k$, 原行列式定义是$sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)...[a_(k j_k)]...[a_(m j_m) ] a_(n j_n)$, 相当于对式1.中的$k, m$项调换，根据n元排列性质，调换两项$(j_m, j_k)$会改变奇偶性，即改变符号，从而行列式相反

上面的公式中，要注意，两个式子比较时，应当固定$j_m, j_k$ 在两个式子中都相等，比如，A从第m行取第1个元素，从第k行取第2个元素；在$A_c$中，就是从第k行取第1个元素（此时第k行全是A第m行的元素），从第m行取第二个元素， 这种情况下，A行列式中该项值和$A_c$的该项值就是符号相反，而n元排列是全排列，包含全部选取情况，全部项都相反，因此整体相反

=== #highlight(fill: rgb(128, 231, 21))[性质5. 矩阵A中任意两行相等，行列式为0]
证:
利用性质4，不妨设$i, k$行相等，则交换这两行，矩阵A没有发生变化，又因为性质4，交换2行符号相反，即：
$
det(A) = det(A_(i<->k))=-det(A) ->det(A) = 0
$
#highlight(fill: rgb(128, 231, 21))[这是多个性质中，唯一一个逻辑证明的]

=== 性质6，矩阵A中，两行成比例，行列式为0
即$mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
K a_(m 1), K a_(m 2), ..., K a_(m n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
) = 0
$

证：根据 性质2.（行列式某行公共系数可以提出），上面的行列式可以写作
$
mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
K a_(m 1), K a_(m 2), ..., K a_(m n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
) = K mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n); 
) = K 0 = 0
$
根据性质5， #highlight[右边行列式中有2行相同]，行列式为0，因此原行列式为0

=== 性质7. 矩阵A中某一行的倍数加到另外一行上，行列式不变
即
$
mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
K a_(m 1) + a_(l 1), K a_(m 2)  + a_(l 2), ..., K a_(m n) +  a_(l n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
) = det(A)
$
证:
利用性质3 #highlight()[行元素求和等与分开的两个行列式求和]， 性质6. #highlight()[两行成倍数，行列式为0]
$
mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
K a_(m 1) + a_(l 1), K a_(m 2)  + a_(l 2), ..., K a_(m n) +  a_(l n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
) &=mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
K a_(m 1), K a_(m 2) , ..., K a_(m n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
)  + mat(
  a_(11), a_(12), ..., a_(1n);
  dots.v, dots.v, ..., dots.v;
a_(m 1), a_(m 2), ..., a_(m n);
dots.v, dots.v, ..., dots.v;
a_(l 1), a_(l 2), ...,  a_(l n);
dots.v, dots.v, ..., dots.v;
a_(n 1), a_(n 2), ..., a_(n n);
) \ &= 0 + det(A) = det(A)
$
性质3 可用于大型矩阵行列式的分解，将其拆分成若干稀疏矩阵的和，使得便于求解。
行列式的性质与矩阵的初等变换息息相关，例如，性质5就对应于系数矩阵中出现0行，此时方程组一定无解或者有无穷多解，性质7对应于矩阵的行叠加，性质4. 对于矩阵的行交换等。 这些操作可能会改变行列式的符号，但不会使其$ m -> 0 或 者 0->m; m!=0$。

== 行列式（行）展开
从行列式的定义出发，在行列式的$n!$ 求和项中，每一项都需要从第$k$行取一个元素，我们以$j_k$表示去了第几个（即第几列元素）。我们不妨以第1行为例子，假设固定第1行取第1个元素，即$j_1 = 1$，这种情况下，后续的$j_2, j_3, ..., j_n$ 还能组成$(n-1)!$ 排列，同时$j_k != 1$。而$j_1$ 一共有 n 种取法$[1, n]$。所以行列式就可以写作

$& det(A) = sum_(j_1,j_2, ..., j_n)(-1)^(tau((j_1,j_2, ..., j_n))) a_(1j_1)a_(2j_2)... a_(n j_n)\
 &= sum_(1,j_2,..., j_n)(-1)^(tau(1,j_2, ..., j_n))a_(1 1)a_(2j_2)... a_(n j_n) + sum_(2,j_2,..., j_n)(-1)^(tau(2,j_2, ..., j_n))a_(1 1)a_(2j_2)... a_(n j_n) + ... + \
 & sum_(n,j_2,..., j_n)(-1)^(tau(n,j_2, ..., j_n))a_(1 n)a_(2j_2)... a_(n j_n) = \
 & sum_(k=1)^n sum_(k,j_2,..., j_n)(-1)^(tau(k,j_2, ..., j_n))a_(1 k)a_(2j_2)... a_(n j_n)
$

观察最后的通项公式$a_(1, k)[a_(2 j_2) ...a_(n j_n)] $中, 排列$j_2, ..., j_n$ 任意一项$j_m != k$, 这相当于划去$a_(1, k)$ 所在列，同时，上式中方括号部分，行指标都不为1（自然序），这相当于划去$a_(1, k)$所在行，总结来说就是$[a_(2 j_2) ...a_(n j_n)]$ 这些项都是取自，将矩阵A中，$a_(1,k)$所在行列划去的剩余的部分，这个部分可以看做一个新的矩阵$A_k$，而

$&sum_(k,j_2,..., j_n)(-1)^(tau(k,j_2, ..., j_n))a_(1 k)a_(2j_2)... a_(n j_n) = a_(1 k)[sum_(j_2, ..., j_n) (-1)^(tau(k,j_2, ..., j_n))a_(2j_2)... a_(n j_n)] ?= a_(1, k)(-1)^(f(1,k)) det(A_k)
$

其中方括号项，几乎接近于$A_k$的行列式定义，主要是符号不同，我们观察$tau(k, j_2, ..., j_n)$ 和$tau(j_2, ..., j_n)$的关系。在第1个位置插入$k$, $j_2, ..., j_n$ 中比k小的，有$k-1$个，比$k$大的有$n-k$个，对于$j_m < k$, 形成逆序，对于$j_m>k$ 形成顺序，所以在第1个位置插入$k$， 相当于增加$k-1$个逆序对，即
$tau(k, j_2, ..., j_n) = tau(j_2, ..., j_n) + k-1 ->(-1)^(tau(k,j_2, ..., j_n)) = (-1)^(k-1)(-1)^(tau(j_2, ..., j_n))
$

上面我们选择从第1行来展开行列式，k就出现则n元排列的第1个位置，当我们选择任意行$i$时，$k$就出现在第$i$个位置，可以表示为$(j_1,j_3, ..., j_(i-1), k, j_(i+1), ...,j_n)$，这种情况下，相当于是n元排列$tau(k, j_1, ..., j_n) j_m != k$将k右移动$i-1$项。每移动一次，改变一次符号，则共改变$(-1)^(i-1)$，结合前文k处于第一项的情形，可得当k处于第i项时:
$
tau(j_1,...,j_(i-1),k,...,j_n) = (-1)^(k-1) (-1)^(i-1) tau(j_1,...,j_n) = \
(-1)^(k+i - 2) tau(j_1,...,j_n) = (-1)^(k+i) tau(j_1,...,j_n); j_m!=k 
$

这里说明一下为什么不是通过将k和第i项交换，这是因为当这两项交换时，同时改变了$j_1, j_2, j_(i-1)$ 和$j_i$ 的顺序，得到的结果是$j_i,j_1,..., k, ...,j_n$，不是我们讨论的顺序

因此行列式按行展开就可以写作:
$
det(A)_i = sum_(j=1)^n (-1)^(i + j) a_(i, j) det(A_(i j))
$
上面的公式中，$det(A_(i j))$叫做余子式，记作$M_(i j)$, $(-1)^(i + j) a_(i, j) M_(i j) 或 M(i,j)$ 叫做代数余子式，记作$C_(i j) 或 C(i,j)$, 因此这个公式也写作$det(A)_i=sum_(j=1)^n C_(i j)$

从这个推导过程和定义，我们自然而然的就得到了一个定理
// todo 计数
#theorem_counter.step()
=== 定理#theorem_counter.display().  `n阶方阵可以被展开成某一行的各元素与其代数余子式的乘积之和`
#theorem_counter.step()
=== 定理#theorem_counter.display() `n阶方阵可以被展开成某一列的各元素与其代数余子式的乘积之和`
证:
考虑$A^T$的行列式，将其按行展开时，等价于原矩阵A的各列展开，而根据性质1. 矩阵的行列式和其转置的行列式相等，则得证

行列等价性

#theorem_counter.step()

=== 定理#theorem_counter.display() . n阶矩阵A的第i行元素与第k行的对应元素的代数余子式之和为0
即$sum a_(i n)A_(k n) = 0$ 其中$i!=k$

前述推导过程中可以发现，行列式按$i$行展开时，其代数余子式只和元素的位置有关和#highlight[元素的值无关]，因此为了构造左边，我们可以构造这样的矩阵
#set math.mat(delim: "[")
$
mat(a_(11), a_(12), ..., a_(1 n);
dots.v, dots.v, dots.v, dots.v;
a_(i 1), a_(i 2), ..., a_(i m);
dots.v, dots.v, dots.v, dots.v;
a_(i 1), a_(i 2), ..., a_(i m) ;
dots.v, dots.v, dots.v, dots.v;
a_(n 1), a_(n 2), ..., a_(n m);
)<- 将 第 k 行 设 置 为 第 i 行 元 素
$
#set math.mat(delim: "|")
这个矩阵，按照第$k$行展开时，就是定理#theorem_counter.display() 的左边，该矩阵有2行一样，根据性质5.(任意两行相等，行列式为0)，其行列式为0

由于行列式的行列等价性，自然可得
#theorem_counter.step()
=== 定理#theorem_counter.display(). n阶矩阵A的第i列元素与第k列的对应元素的代数余子式之和为0

=== 范德蒙德行列式
形如
$mat(1,1,..., 1;
a_1, a_2, ..., a_n;
a_1^2,a_2^2,..., a_n^2;
a_1^(n-1), a_2^(n-1), ..., a_n^(n-1)
)
$ 的行列式，称为范德蒙德行列式，该行列式计算存在公式$product_(1<=j<i<=n)(a_i -a_j)$，可以直接计算得出。

证明（精彩推演）:
对于n=2的情形，$mat(1,1;a_1, a_2) = (a_2 - a_1)$成立，现在，我们假设对于$n-1$阶成立，我们证明n阶也成立
$
mat(1,1,..., 1;
a_1, a_2, ..., a_n;
a_1^2,a_2^2,..., a_n^2;
a_1^(n-1), a_2^(n-1), ..., a_n^(n-1)
) ->(第 n 行 + -a_1 第 n-1行) ->
mat(1,1,..., 1;
a_1, a_2, ..., a_n;
a_1^2,a_2^2,..., a_n^2;
0, a_2^(n-2)(a_2 - a_1), ..., a_n^(n-2)(a_n - a_1)
)\ ->(第 n -1 行 + (-a_1) n - 2行) ->
mat(1,1,..., 1;
a_1, a_2, ..., a_n;
a_1^2,a_2^2,..., a_n^2;
dots.v, dots.v,dots.v, dots.v;
0, a_2^(n-3)(a_2 - a_1), ..., a_n^(n-3)(a_n - a_1);
0, a_2^(n-2)(a_2 - a_1), ..., a_n^(n-2)(a_n - a_1)
)
$
以此类推，我们从最后一行开始，以此减去前一行的$a_1$倍，最终能使得第1列除第1行外全为0:
$
mat(1,1,..., 1;
0, a_2 - a_1, ..., a_n - a_1;
0,a_2(a_2 - a_1),..., a_n(a_n-a_1);
dots.v, dots.v,dots.v, dots.v;
0, a_2^(n-3)(a_2 - a_1), ..., a_n^(n-3)(a_n - a_1);
0, a_2^(n-2)(a_2 - a_1), ..., a_n^(n-2)(a_n - a_1)
)
$
将其按第1列展开，则
$
det(A) = 1 (-1)^(1+1) mat(
a_2 - a_1, ..., a_n - a_1;
a_2(a_2 - a_1),..., a_n(a_n-a_1);
dots.v,dots.v, dots.v;
a_2^(n-3)(a_2 - a_1), ..., a_n^(n-3)(a_n - a_1);
a_2^(n-2)(a_2 - a_1), ..., a_n^(n-2)(a_n - a_1)) <- 第 1 列 有 公 共 系 数 a_2 - a_1 ...
$
根据性质2.（单行或者#highlight[列]公共系数可提前），上式可以化作:
$(a_2 - a_1)(a_3 - a_1)(...)(a_n-a_1) mat(1, ..., 1;
a_2,..., a_n;
dots.v,dots.v, dots.v;
a_2^(n-3), ..., a_n^(n-3);
a_2^(n-2), ..., a_n^(n-2))
$ 右边的行列式即第(n-1)阶范德蒙行列式(注意，其其实元素下标是$a_2$), 即$product_(1 <= 1 < i <= n)(a_i - a_1)product_(2 <=j<i<=n)(a_i - a_j) ->product_(1 <= j < i <= n)(a_i - a_j)$

范德蒙德行列式可以通过计算公式直接求解

至此，行列式求解已经有
1. 化成上三角计算（增广矩阵阶梯型）
2. 按行、按列展开
3. 直接分解成多个行列式的和
4. 范德蒙德行列式 公式求解

== 线性方程组的解和行列式的关系
0. 当线性方程组个数少于未知量数目时，一定没有唯一解，因此我们只考虑n个未知量、n个方程的方程组。
  - 如果方程组个数多于未知量数目，在有解的情况下，有一部分方程一定是多余的；无解则任意方程出现$0=d$的情况，比如$cases(x_1 = 2,x_1=3)$ 这个未知量只有1个，方程组2个，但是这个方程组无解，因为化简第2行，有$0=1$

1. 当线性方程组组的增广矩阵$hat(A)$ 化成阶梯型$hat(J)$,其系数矩阵也变成阶梯型$J$,如果$hat(J)$对应的方程组出现了$0=d$这样的方程，则方程组无解，此时$J$中有0行，进而$|J| = 0$。同样的，当出现$hat(J)$ 有$0=0$情况时，方程组有无穷多解，此时 $J$ 中也存在0行， $|J| = 0$
2. 当$hat(J)$ 没有$0=d$ 或者0行时，此时$J$是一个上三角矩阵，而且其对角线元素均不为0（主元定义），根据上三角矩阵的行列式等于对角线元素乘积，因此$|J| != 0$

我们注意到，将系数矩阵$A$化简为$J$ 需要经过一系列初等行变换，而初等行变换不会改变行列式的非零性质（但是可能会改变符号，比如行交换），因此有
#theorem_counter.step()
=== 定理 #theorem_counter.display(). 线性方程组有唯一解的充要条件是系数矩阵行列式不为0
==== 推论，对于线性齐次方程组，其有非0解的充要条件是其系数矩阵的行列式为0
=== 线性方程组的解的公式表示
线性方程组有解的情况下，其解可以表示为$[mat(B_1)/mat(A), mat(B_2)/mat(A), ..., mat(B_n)/mat(A)]$，其中$B_i$是将系数矩阵A的第$i$列替换为常数项得到的矩阵

下面给出形式证明（即验证结果正确性，但不推导），把$x_i = mat(B_i)/mat(A)$代入增广矩阵中的第i行
$
sum_(j=1)^(n) a_(i j)mat(B_j)/mat(A) &= 1/mat(A) sum_j a_(i j) (sum_(k=1)^n b_k A_(k j)) <-|B_j| 按 列 展 开 \
&= 1/mat(A) sum_j sum_k a_(i j) b_k A_(k j) = 1/mat(A) sum_k b_k sum_j a_(i j) A_(k j) <- 此 处 更 改 了 求 和 顺 序
$
对于$ sum_j a_(i j) A_(k j)$ 当$k!=i$ 时，根据定理5. 其值为0，当$k=i$时，就是$sum_j a_(i j) A_(i j) = mat(A)$ 因此$ 1/mat(A) sum_k b_k sum_j a_(i j) A_(k j)=1/mat(A) b_i mat(A) = b_i$

这里有几个点要注意：
1. 代数余子式只和元素的位置、有关，和按行、按列展开无关，某个元素的代数余子式，既可以看做按行展开的一部分，也可以看做按列展开的一部分
2. 双重求和的性质

定理7. 和 线性方程组的公式表示合起来称作 `克拉默(Cramer)法则`
== 拉普拉斯定理
在n阶矩阵中，任意选择k行、k列，这些行列交叉位置的元素按照原来的排定顺序形成的k阶矩阵的行列式称作A的一个#highlight[k阶子式],即从原矩阵中选择$i_1, i_2, ..., i_k$行，$j_1, j_2, ..., j_k$列，组成的新的行列式$mat(a_(i_1 j_1), a_(i_1, j_2), ..., a_(i_1 j_k);a_(i_2 j_1), a_(i_2, j_2), ..., a_(i_2 j_k); ...,...,...,...;a_(i_k j_1), a_(i_k, j_2), ..., a_(i_k j_k);)$，
#set math.mat(delim: "(")
记作$A mat(i_1,i_2, ..., i_k;j_1,j_2, ..., j_k) (*)$

从A中划去上述选定的行和列，剩余的元素按照原来的次序，组成一个$n-k$阶矩阵，其行列式称为k阶子式的余子式，与单元素的余子式相仿，前面乘以$(-1)^(sum i_k + sum(j_k))$，称作k阶子式的代数余子式。不妨设$i^'_1, i^'_2, ...,i^'_(n-k) = (1, ...,n) \\(i_1,i_2,..., i_k);j^'_1, j^'_2, ...,j^'_(n-k) = (1, ...,n) \\(i_1,i_2,..., i_k)$ 则$(*)$得余子式就是$A mat(i^'_1, i^'_2, ...,i^'_(n-k);j^'_1, j^'_2, ...,j^'_(n-k))$

#highlight(fill: rgb(200, 50, 128,))[拉普拉斯定理 ]
// #set math.mat(delim: "|")

n阶矩阵A，取$i_1,i_2, ..., i_k$ ($i_1 < i_2 ... < i_k$)行，则由这些行内元素组成的所有k阶子式与它们对应的代数余子式之和等于$mat(A)$

即$mat(A) = sum_(1 <= j_1 <j_2 < ... < j_k <= n)A mat(i_1,i_2, ..., i_k;j_1,j_2, ..., j_k) (-1)^(sum(i_l)+sum(j_l))A mat(i^'_1, i^'_2, ...,i^'_(n-k);j^'_1, j^'_2, ...,j^'_(n-k))$

拉普拉斯展开较为麻烦，这里不给出证明过程（以后有时间在写）。这里需要记住拉普拉斯展开的一个重要推论，即:
$
O=mat(
  a_(11),a_(12),...,a_(1 k), 0, 0, 0, ..., 0;
  a_(21,),a_(22),...,a_(2 k),0, 0, 0, ..., 0;
  dots.v, dots.v,dots.v,dots.v, dots.v,dots.v, dots.v,dots.v , dots.v;
  a_(k 1,),a_(k 2),...,a_(k k),0, 0, 0, ..., 0;
  b_(1 1),b_(1 2), ...,b_(1 k),c_(1,1), c_(1,2), c_(1,3), ..., c_(1,t);
  b_(2 1),b_(2 2), ...,b_(2 k),c_(2,1), c_(2,2), c_(2,3), ..., c_(2,t);
  dots.v, dots.v,dots.v,dots.v, dots.v,dots.v, dots.v,dots.v , dots.v;
  b_(t 1),b_(t 2), ...,b_(t k),c_(t,1), c_(t,2), c_(t,3), ..., c_(t,t);
)
$
可以视作以下4个矩阵组成:
$A_k = mat(a_(11),a_(12),...,a_(1 k);a_(21,),a_(22),...,a_(2 k); dots.v, dots.v,dots.v,dots.v;a_(k 1,),a_(k 2),...,a_(k k)); 
B = mat( b_(1 1),b_(1 2), ...,b_(1 k);dots.v, dots.v,dots.v,dots.v;b_(t 1),b_(t 2), ...,b_(t k)); 
C_t = mat(c_(1,1), c_(1,2), c_(1,3), ..., c_(1,t);dots.v,dots.v, dots.v,dots.v , dots.v;c_(t,1), c_(t,2), c_(t,3), ..., c_(t,t);), bold(0), O=mat(bold(A), 0;bold(B), bold(C)) -> |O| = |A||C|$